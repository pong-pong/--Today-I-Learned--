# 객체지향 설계 원칙 (SOLID)
객체지향 기술은 어느 날 한 번에 만들어진 것이라기보다 오랜 시간에 걸쳐 점진적으로 발전해온 기술입니다. 그렇기 때문에 객체지향 프로그래밍 언어의 종류도 다양하며 그 기술을 받아들이고 적용하는 관점과 기법 또한 조금씩 차이가 있습니다. 그럼에도 이들에게는 '객체지향'이라는 이름으로 묶을 수 있는 분명한 특징이 있습니다.

객체지향 설계 원칙은 객체지향의 특징을 잘 살릴 수 있는 설계의 특징을 말합니다. 원칙이라는 건 언제, 어떤 상황에서든 무조건 100% 지켜야 하는 절대적인 기준이라기보다, 예외는 있겠지만 대부분의 상황에 잘 들어맞는 가이드라인과 같은 것이라고 할 수 있습니다. 디자인 패턴은 일반적인 상황보다 특별한 상황에서 발생하는 문제에 대한 좀 더 구체적인 솔루션이라고 한다면, 객체지향 설계 원칙은 좀 더 일반적인 상황에서 적용 가능한 설계 기준이라고 볼 수 있습니다. 당연한 이야기이지만 객체지향 디자인 패턴은 대부분 객체지향 설계 원칙을 잘 지켜서 만들어져있습니다.

## SOLID
### SRP - 단일책임 원칙 (Single Responsibility Principle)
__'모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화 해야한다'__ 는 프로그래밍 원칙입니다.  변경하려는 단 하나의 이유만을 가져야 한다는 것입니다. 변경하려는 이유가 두 가지 이상이라면 나쁜 설계일 수 있으니 해당 클래스는 관심사 분리를 통해 각각의 책임(변경이 일어나는 이유)을 독립시키는게 좋습니다.

### OCP - 개방 폐쇄 원칙 (Open-Closed Principle)
__'소프트웨어 개체(클래스, 모듈 등)는 '확장에는 열려있어야 하고, 변경에는 닫혀있어야한다'__ 는 프로그래밍 원칙입니다. 이 원칙이 제대로 적용되지 않아 소프트웨어 개발 작업에 이용된 많은 개체 중 하나에 수정(변경)을 일으킬 때 그 개체를 이용하는 다른 개체들을 모두 수정해야 한다면 수정 자체의 작업도 번거로울 뿐더러 수정 과정에서 다른 개체들에 추가 문제가 발생했을 경우까지 두 번 생각해야 하는 상황이 발생합니다.

### LSP - 리스코프 치환원칙 (Liskov Subsitution Principle)
__'상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 작동해야한다'__ 는 프로그래밍 원칙입니다. 다시말해 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 말과 같습니다. 만약 부모클래스에서 작동하는 로직을 수정해서 자식클래스에 구현했다면(`@Override`) 자식 객체를 사용한 곳에 부모 객체로 치환했을 때 정상적으로 작동하지 못하므로 LSP를 어기는 경우가 됩니다.

### ISP - 인터페이스 분리원칙 (Interface Segregation Principle)
__'클라이언트(객체를 사용하는 소비자. e.g 메서드, 클래스 등)가 자신이 이용하지 않는 메서드에 의존하지 않아야한다'__ 는 프로그래밍 원칙입니다. 기능이 많은 큰 덩어리의 인터페이스를 구현하는 대신 이를 구체적이고 작은 단위들로 분리시켜 사용함으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 하는게 좋습니다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜(낮은 결합도) 리팩토링, 수정, 재배포를 쉽게 할 수 있게됩니다.

### DIP - 의존관계 역전원칙 (Dependency Inversion Principle)
__'고수준 모듈(의미있는 기능을 제공하는 모듈)은 저수준 모듈(고수준 모듈을 구현하기 위해 필요한 하위 기능의 실제 구현)의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다'__ 는 프로그래밍 원칙입니다. 다형성을 이용한 DI(Dependency Injection, 의존성 주입)를 통해 해결이 가능합니다.