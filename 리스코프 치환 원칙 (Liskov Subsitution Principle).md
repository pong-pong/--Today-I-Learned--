# 리스코프 치환 원칙 (LSP, Liskov Subsitution Principle)
리스코프 치환 원칙은 '상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 작동해야한다'는 프로그래밍 원칙입니다. 이는 곧 상위타입을 상속받아 하위의 객체를 생성했을 때 (예를 들어) `isCheck()` 와 같은 플래그 메소드를 사용해야한다면 이들은 상속보다는 별개의 타입으로 구현해주는 것이 맞다고 이야기하는 것입니다. 대표적인 예제로 정사각형 클래스를 직사각형 클래스로부터 파생시키는 경우가 있습니다. 또한 상위 타입에서 지정한 리턴값 등을 하위 타입이 상속받았을 때 전혀 다른 값을 리턴한다면 이 역시 LSP를 위배하는 경우 중 하나입니다. 예를 들어 `a()` 라는 메소드가 부모클래스에서 `b` 라는 경우에 `"a"` 를 리턴한다면 이를 구현한 하위클래스도 `b` 라는 경우에 `"a"` 를 리턴해야지 `"b"` 를 리턴한다거나, 하위클래스에서 상위클래스에서 지정한 예외 외의 다른 예외를 던진다거나 하는 경우가 있어서는 안 된다는 것입니다. 다시 말해 하위형에서 상위형의 불변조건은 반드시 유지되어야 합니다. 

## 리스코프 치환 원칙의 강제
#### 하위형에서 메서드 인수의 반공변성
#### 하위형에서 반환형의 공변성
#### 하위형에서 메소드는 상위형 메소드에서 지정한 예외 외의 다른 예외를 던지는 것을 비허용
#### 하위형에서 선행조건은 강화될 수 없음
#### 하위형에서 후행조건은 약화될 수 없음
#### 하위형에서 상위형의 불변조건은 반드시 유지되어야 함

위의 목록은 리스코프 치환 원칙이 강제하는 사항들인데, 반공변성은 타입 `T` 의 상위타입에 대해서 허용한다는 것이고, 공변성은 타입 `T` 를 확장한 타입(하위 구현 객체)에 대해서 허용한다는 것입니다. 또한 선행조건은 연산이 호출될 시점에 만족이 되어야 하는 조건을 뜻하며, 후행조건은 선행조건이 만족된 상태에서 수행이 완료될 때 만족해야 하는 조건을 뜻합니다. 즉, 후행조건은 연산의 구현에서 보장을 해야하는 부분입니다. 

상속은 다형성과 따로 생각할 수 없습니다. 그리고 다형성으로 인한 이점을 얻기 위해서는 하위 클래스가 상위 클래스와 클라이언트 간의 규약을 위배해서는 안 됩니다. 결국 LSP를 만족한다면 다형성을 통한 확장 원리인 [OCP(Open-Closed Principle, 개방 폐쇄 원칙)](https://github.com/pong-pong/--Today-I-Learned--/blob/master/%EA%B0%9C%EB%B0%A9%20%ED%8F%90%EC%87%84%20%EC%9B%90%EC%B9%99.md)를 제공하게 됩니다. 이는 즉 LSP는 OCP를 구성하는 구조가 된다는 말과 같습니다. [객체 지향 설계 원칙](https://github.com/pong-pong/--Today-I-Learned--/blob/master/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%20%EC%84%A4%EA%B3%84%20%EC%9B%90%EC%B9%99%20(SOLID).md)은 이렇게 서로가 서로를 이용하기도 하고 포함하기도 하는 특징이 있습니다. 

LSP는 규약을 준수하는 상속구조를 제공함으로써 이를 바탕으로한 OCP를 통해 확장하는 부분에 다형성을 제공하여 변화에 열려있는 프로그램을 만들 수 있도록 합니다.